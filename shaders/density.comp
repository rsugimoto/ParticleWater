#version 430

layout(local_size_x=32) in;

layout(std430) buffer densities{ float dns[];};
layout(std430) buffer positions_in{ vec4 pos_in[];};
layout(std430) buffer bucket{ uvec4 bkt[];};
uniform uint num_particles;
uniform uint bucket_res;
uniform double re;
uniform double re2;
uniform double re9;
uniform float mass;

#define POW3(x) ((x)*(x)*(x))

const double PI = 3.14159265358979323846264338327950288; 

double W(vec3 r){
    const double c = 315.0/(64.0*PI);
    double abs_r = length(r);
    return abs_r<re?c*POW3(re2-abs_r*abs_r)/re9:0.0;
}

void main(){
    uvec3 GlobalInvocationSize = gl_NumWorkGroups*gl_WorkGroupSize;
    uint threadsTotal = GlobalInvocationSize.x*GlobalInvocationSize.y*GlobalInvocationSize.z;
    uint threadIndex = gl_GlobalInvocationID.z*GlobalInvocationSize.y*GlobalInvocationSize.x
                    +gl_GlobalInvocationID.y*GlobalInvocationSize.x+gl_GlobalInvocationID.x;

    for (uint i = threadIndex; i < num_particles; i+= threadsTotal){
        vec3 pos = clamp(pos_in[i].xyz, 0.0, 1.0);
        uvec3 idx_3d = uvec3(pos*float(bucket_res-1));

        double rho = 0.0;
        for (int x_offset=-1; x_offset<=1; x_offset++){
            for (int y_offset=-1; y_offset<=1; y_offset++){
                for (int z_offset=-1; z_offset<=1; z_offset++){
                    if (0<=idx_3d.x+x_offset && idx_3d.x+x_offset<bucket_res &&
                        0<=idx_3d.y+y_offset && idx_3d.y+y_offset<bucket_res &&
                        0<=idx_3d.z+z_offset && idx_3d.z+z_offset<bucket_res )
                    {
                        uint bkt_j = bucket_res * (bucket_res * (idx_3d.z+z_offset) + (idx_3d.y+y_offset)) + (idx_3d.x+x_offset);
                        for (int k = 0; k<4; k++){
                            uint j = bkt[bkt_j][k];
                            if (j == num_particles) break;
                            rho += double(mass)* W(pos.xyz - pos_in[j].xyz);
                        }
                    }
                }
            }
        }

        vec3 r = vec3(re);
        if(pos.x<re) r.x += pos.x;
        if(pos.y<re) r.y += pos.y;
        if(pos.z<re) r.z += pos.z;
        if(pos.x>1.0-re) r.x -= pos.x;
        if(pos.y>1.0-re) r.y -= pos.y;
        if(pos.z>1.0-re) r.z -= pos.z;
        vec3 abs_r = abs(r);
        float min_r = min(abs_r.x, min(abs_r.y, abs_r.z));
        //if (min_r<re)rho += min_r; //TODO: apply wall function correctly

        dns[i] = float(rho);
    }
}
